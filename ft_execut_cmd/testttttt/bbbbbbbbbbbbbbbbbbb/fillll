
#include "../minishell.h"

SRC= minishell.c \
	lexer_utils.c \
	lexer.c \
	ft_handle_synx.c \
	ft_nodes_env.c \
	ft_free.c \
	ft_parsser.c\
	ft_parsser_utils_2.c \
	ft_parsser_utils.c \
	ft_direction.c \
	ft_direction_utils.c \
	ft_execut_cmd/execute.c ft_execut_cmd/functions.c ft_execut_cmd/ft_cd.c   ft_execut_cmd/ft_pwd.c \
    ft_execut_cmd/ft_export.c ft_execut_cmd/ft_env.c    ft_execut_cmd/ft_unset.c ft_execut_cmd/ft_echo.c  ft_execut_cmd/redirectons.c ft_execut_cmd/execur_cmd.c \
	ft_execut_cmd/funct_redir.c ft_execut_cmd/ft_exit.c   ft_execut_cmd/ft_herdoc.c ft_execut_cmd/utilis_herdoc.c\

OBJ = ${SRC:.c=.o}

CFLAGS = -Wall -Wextra -Werror -g -fsanitize=address

CC = cc


NAME = minishell

LIBFT = ./includes/libft/libft.a
FLDLIBFT= ./includes/libft

#include readLine in MacOS
INRL = -I/goinfre/bouhammo/homebrew/opt/readline/include
LNRL= -L/goinfre/bouhammo/homebrew/opt/readline/lib -lreadline



all : ${LIBFT} ${NAME}

%.o: %.c minishell.h structures.h
	${CC} ${CFLAGS} -c  $< -o $@

${NAME} : minishell.h structures.h ${OBJ}
		${CC} ${FLAGS} ${LIBFT}  ${INRL} ${LNRL} ${SRC}  -o ${NAME}

${LIBFT}:
	make -C ${FLDLIBFT}
	make bonus -C ${FLDLIBFT}

clean:
	make fclean -C ./includes/libft
	@rm -rf ${OBJ}
	@echo "\033[34mminishell is clean from object files\033[0m"

fclean: clean
	@rm -rf ${NAME}
	@echo "\033[34mminishell is clean from program file\033[0m"

re : fclean all

.PHONY: all clean fclean re



#ifndef STRUCTURES_H
# define STRUCTURES_H
# include <stdbool.h>
typedef struct s_idx
{
	int					i;
	int					j;
	int					len;
	int					start;
	int					state;
	int					in_s;
	int					in_d;
}						t_idx;

typedef enum e_token
{
	nothing = 0,
	WORD = -1,
	WHITE_SPACE = ' ',
	NEW_LINE = '\n',
	QOUTE = '\'',
	DOUBLE_QUOTE = '\"',
	ENV = '$',
	PIPE_LINE = '|',
	REDIR_IN = '<',
	REDIR_OUT = '>',
	HERE_DOC,
	DREDIR_OUT,
}						t_token;

typedef struct s_redirect
{
	t_token				type;
	char				*store;
	struct s_redirect	*next;
}						t_redirect;

typedef enum e_state
{
	D,
	S,
	G,
	NUL,
}						t_state;
typedef struct s_splitor
{
	char				*in;
	int					len;
	enum e_token		type;
	enum e_state		state;
	struct s_splitor	*next;
}						t_splitor;

typedef struct s_envarment
{
	char				*var;
	char				*data;
	struct s_envarment	*next;
}						t_envarment;

typedef struct s_command
{
	char				*content;
	char				**arg;
	t_redirect			*doc;
	char				**store_her;
	int					is_pipe;

	int					len;
	struct s_command	*next;
}						t_command;

typedef struct s_here_doc
{
	int					indx_cmd;
	int					indx;
	char				*store;
	int					fd;
	bool				is_expanded;
	struct s_here_doc	*next;
}						t_here_doc;

#endif


#ifndef MINISHELL_H
# define MINISHELL_H

# define _GNU_SOURCE

// call all the libriries we need in the project
# include "./includes/libft/libft.h"
# include "structures.h"
# include <curses.h>
# include <dirent.h>
# include <errno.h>
# include <fcntl.h>
# include <readline/history.h>
# include <readline/readline.h>
# include <signal.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <sys/ioctl.h>
# include <sys/stat.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <termios.h>
# include <unistd.h>
#include <stdbool.h>

// function we use

//////////////////////////////  Parsser  /////////////////////////////////
// ---------
void		print_t_command(t_splitor *cmd);
void		print_redirect_list(t_redirect *head);
// ---------
void		ft_free_env(t_envarment **x);
void		ft_free_lexer(t_splitor **x);
void		ft_free_command(t_command *lst);
void		ft_free_split(char **list);
// ---------
int			ft_search(char *s, char *d);
int			ft_isspace(char c);
t_token		ft_get_token(char str_input);
int			ft_check_input(char str_input);
t_state		ft_get_state(t_idx *var, char str_input);
int			ft_condition(t_splitor *start);
int			ft_handler_syn_error(t_splitor **x);
int			ft_lexer(char *input, t_splitor **x);
// ---------
t_envarment	*new_node(void *var, void *data);
void		add_back_node(t_envarment **lst, t_envarment *new);
t_envarment	*ft_stock_envarment(char **env);
void		ft_check_env(t_splitor **x, t_envarment *my_env);
// ---------
void		ft_command(t_splitor **x, t_command **cmd);
void		ft_add_command(t_command **lst, t_command *new);
t_command	*ft_new_command(int count, t_splitor **tmp_x);
t_command	*ft_last_command(t_command *lst);
// ---------
void		ft_not_pipe(t_command **new_node, int *i, t_splitor **tmp_x);
int			ft_check_command(t_splitor *tmp_x);
void		ft_skip_spaces(t_splitor **tmp_x);
void		ft_double_and_sigle(t_splitor **tmp_x, int *i,
				t_command **new_node);
// ---------
void		ft_check_doc(t_command **new_node);
t_redirect	*ft_new_redir(void *content, t_token type);
void		ft_add_redir(t_redirect **lst, t_redirect *new);
t_redirect	*ft_last_redir(t_redirect *lst);





//////////////////////  Execution  ////////////////////////

void            ft_exute(t_envarment *var, t_command *list , char **env);
int             ft_strcmp(char *s1, char *s2);
char            **create_argv(t_splitor *elem) ;
char            *path_command(char *ptr);
t_envarment 	*ft_stock_envarment(char **env);
int             test_exist(t_envarment *var , char **list);

void            free_args(char **args);// ft_export
char            **split_line(char *ptr);// ft_export
char            **split_var(char *ptr);// ft_env
void            print_export(t_envarment *var, t_command *str);
void            execution_cmd(t_command         *list ,char **new, char **env);
void            hundle_command(t_command *list ,char **env);
int				hundle_redirections(t_command *list);
void			handle_pipe( t_command *list, char **env);
// void			handle_here_doc(t_command *tmp);

///////////////////////// Redirections  //////////////////////////
void			hundle_redir_out(char 		*file);
void			hundle_redir_in(char 		*file);
void			hundle_dredir_out(char	 	*file);



/////////////////////////  her doc  //////////////////////////
int 			herdoc_exist(t_command *list);
void			handle_here_doc(t_command *tmp , char **env);
t_here_doc  	*new_node_her(int idx ,int i, char *file, int fd, bool expand);
void    		add_back_node_her(t_here_doc **her, t_here_doc *new_her);


/////////////////////////  function redirections  //////////////////////////
char 			**get_len(char **args , t_redirect *redir);
char			*git_type_redir(t_redirect *redir);
char 			**ft_new_args(char **args , t_redirect *redir);
int 			test_redir_here_doc(t_command *list);


/////////////////////////  execut_cmd  //////////////////////////
int             pipe_exist(t_command *list);
int  			num_pipe(t_command *list);
char 			*command_execut(t_command *list);
int 			**return_pipe(int num_cmd);
t_command 		*get_list_command(t_command *list);
void    		close_free_wait( int *pids, int **pipefd, int num_cmd , t_command *tmp_cmd);
void       	    child_process(int ** pipefd,int  i,t_command *tmp_cmd,char **env , int num_cmd );//, int *red);
void 			handle_pipe(t_command *list, char **env);


/////////////////////////  signal  //////////////////////////





// ///////            Commands         //////////////////////////////////
// int			builtin_cmd(t_envarment *var ,t_command *list ,char  **env);
int            ft_cd(t_command *list);
int            ft_pwd(t_command *va_list);
int            ft_export( t_envarment *var , t_command *str);
int            ft_env( t_envarment *var);
int            ft_unset(t_envarment *var , t_command *list);
int            ft_echo(t_command *list, char **env);
void            ft_echo_flag(t_command *list);
int                     ft_exit(t_envarment *var ,t_command *list);



#endif



#include "minishell.h"

void	ff(void)
{
	system("leaks minishell");
}

void	ft_join_quote(t_splitor **tmp_x, char *s)
{
	while ((*tmp_x) != NULL && ((*tmp_x)->state == D || (*tmp_x)->state == S))
	{
		ft_strjoin(s, (*tmp_x)->in);
		(*tmp_x) = (*tmp_x)->next;
	}
	free(s);
}

void	print_envarment(t_envarment *env)
{
	t_envarment	*current;

	current = env;
	while (current != NULL)
	{
		printf("%s=%s\n", (char *)current->var, (char *)current->data);
		current = current->next;
	}
}
void	handle_sig(int sig)
{
	if (sig == SIGINT)
	{
		printf("\n");
		rl_on_new_line();
		rl_redisplay();
	}
}

void	ft_initialize(t_splitor *x, t_command *cmd, t_envarment *my_env,
		char **env)
{
	(void) env;
	ft_check_env(&x, my_env);
	ft_command(&x, &cmd);
	// ft_exute(my_env, cmd, env);
	ft_free_lexer(&x);
}
void	ft_reader(t_splitor *x, t_command *cmd, t_envarment *my_env, char **env)
{
	char	*str_input;

	while (1)
	{
		str_input = readline("\033[36mâž¨ minishell $:\033[0m  ");
		// if (ft_search(str_input, "exit") )
		// 	exit (1);
		if (!str_input)
		{
			printf("exit\n");
			//
			exit(0);
		}
		if (ft_strlen(str_input) > 0)
			add_history(str_input);
		if (ft_lexer(str_input, &x))
		{
			ft_putstr_fd("Syntax Error:\n", 2);
			ft_free_lexer(&x);
		}
		else
			ft_initialize(x, cmd, my_env, env);
		ft_free_command(cmd); 
		cmd = NULL;
		x = NULL;
		free(str_input);
	}
}
void ft_d(int signal)
{
	printf("fdf\n");
	if (signal == SIGQUIT)
		printf("quit\n");
}
int	main(int ac, char **av, char **env)
{
	t_splitor	*x;
	t_envarment	*my_env;
	t_command	*cmd;

	signal(SIGINT, handle_sig);
	// signal(SIGQUIT, SIG_IGN);
	// signal(SIGQUIT, ft_d);
	(void)ac;
	(void)av;
	my_env = NULL;
	my_env = ft_stock_envarment(env);
	using_history();
	x = NULL;
	cmd = NULL;
	ft_reader(x, cmd, my_env, env);
	ft_free_env(&my_env);
}

int	pipe_exist(t_command *list)
{
	t_command	*tmp;

	tmp = list;
	while (tmp)
	{
		if (tmp->content[0] == '|')
			return (1);
		tmp = tmp->next;
	}
	return (0);
}

int	num_pipe(t_command *list)
{
	t_command	*tmp;
	int			i;

	tmp = list;
	i = 0;
	while (tmp)
	{
		if (tmp->content[0] == '|')
			i++;
		tmp = tmp->next;
	}
	return (i);
}

char	*command_execut(t_command *list)
{
	char	*ptr;

	if (list == NULL)
	{
		fprintf(stderr, "Error: Command not found\n");
		return (NULL);
	}
	ptr = path_command(list->content);
	if (!ptr)
		perror("Error: Command not found");
	return (ptr);
}

int	**return_pipe(int num_cmd)
{
	int	**pipe;
	int	i;

	pipe = (int **)malloc(sizeof(int *) * num_cmd);
	if (!pipe)
	{
		perror("malloc");
		exit(EXIT_FAILURE);
	}
	i = 0;
	while (i < num_cmd)
	{
		pipe[i] = (int *)malloc(sizeof(int) * 2);
		if (!pipe[i])
		{
			perror("malloc");
			exit(EXIT_FAILURE);
		}
		i++;
	}
	return (pipe);
}

t_command	*get_list_command(t_command *list)
{
	t_command	*tmp;
	t_command	*head;
	t_command	*prev;

	tmp = NULL;
	head = NULL;
	prev = NULL;
	while (list)
	{
		if (list->content[0] == '|')
			list = list->next;
		else
		{
			tmp = (t_command *)malloc(sizeof(t_command));
			if (!tmp)
			{
				perror("malloc");
				exit(EXIT_FAILURE);
			}
			tmp->content = list->content;
			tmp->arg = list->arg;
			tmp->doc = list->doc;
			tmp->next = NULL;
			if (prev)
				prev->next = tmp;
			else
				head = tmp;
			prev = tmp;
			list = list->next;
		}
	}
	return (head);
}

void	close_free_wait(int *pids, int **pipefd, int num_cmd,
		t_command *tmp_cmd)
{
	int	i;
	int	j;
	int	status;

	close(pipefd[num_cmd - 1][0]);
	close(pipefd[num_cmd - 1][1]);
	j = 0;
	while (j < num_cmd)
	{
		if (waitpid(pids[j], &status, 0) == -1)
		{
			perror("waitpid");
			exit(EXIT_FAILURE);
		}
		j++;
	}
	i = 0;
	free(pids);
	while (i < num_cmd - 1)
	{
		free(pipefd[i]);
		i++;
	}
	free(pipefd);
	free(tmp_cmd);
}
void	child_process(int **pipefd, int i, t_command *tmp_cmd, char **env,
		int num_cmd) //, int *red)
{
	char	**new_args;
	char	*ptr;

	// (void)red;
	// printf("///////////////////*///////////////*///////////////*/////////////*\n\n");
	// if( *red  == 1)
	// {
	//     int j   = 0;
	//     while (j < num_cmd - 1)
	//     {
	//         close(pipefd[j][0]);
	//         close(pipefd[j][1]);
	//         j++;
	//     }
	//     exit(EXIT_FAILURE);
	// }
	if (i > 0)
	{
		close(pipefd[i - 1][1]);
		dup2(pipefd[i - 1][0], STDIN_FILENO);
		close(pipefd[i - 1][0]);
	}
	if (i < num_cmd - 1)
	{
		close(pipefd[i][0]);
		dup2(pipefd[i][1], STDOUT_FILENO);
		close(pipefd[i][1]);
	}
	new_args = ft_new_args(tmp_cmd->arg, tmp_cmd->doc);
	ptr = command_execut(tmp_cmd);
	if (!ptr)
		exit(EXIT_FAILURE);
	execve(ptr, new_args, env);
	perror("execve failed");
	exit(EXIT_FAILURE);
}

void	handle_pipe(t_command *list, char **env)
{
	int			num_cmd;
	int			**pipefd;
	t_command	*tmp_cmd;
	pid_t		*pids;
	int			i;

	num_cmd = num_pipe(list) + 1;
	pipefd = return_pipe(num_cmd);
	// int red = 0;
	tmp_cmd = get_list_command(list);
	pids = (pid_t *)malloc(sizeof(pid_t) * num_cmd);
	if (!pids)
	{
		perror("malloc");
		exit(EXIT_FAILURE);
	}
	i = 0;
	while (i < num_cmd && tmp_cmd)
	{
		if (pipe(pipefd[i]) == -1)
		{
			perror("pipe");
			exit(EXIT_FAILURE);
		}
		pids[i] = fork();
		if (pids[i] == -1)
		{
			perror("fork");
			exit(EXIT_FAILURE);
		}
		// red = hundle_redirections(list);
		if (pids[i] == 0)
		{
			// printf(" id child = %d\n", i);
			child_process(pipefd, i, tmp_cmd, env, num_cmd); //, &red);
		}
		if (i > 0)
		{
			close(pipefd[i - 1][0]);
			close(pipefd[i - 1][1]);
		}
		tmp_cmd = tmp_cmd->next;
		i++;
	}
	close_free_wait(pids, pipefd, num_cmd, tmp_cmd);
}
#include "../minishell.h"

void	execution_cmd(t_command *list, char **new, char **env)
{
	char	*ptr;
	int		pid;
	int		status;

	pid = fork();
	if (pid < 0)
		perror("fork");
	else if (pid == 0)
	{
		if (herdoc_exist(list) == 1)
		{
			handle_here_doc(list, env);
		}
		printf("--------------------------\n");
		if (new[0][0] == '/')
			ptr = new[0];
		else
			ptr = path_command(new[0]);
		if (!ptr)
		{
			hundle_redirections(list);
			exit(127);
		}
		hundle_redirections(list);
		if (execve(ptr, new, env) == -1)
			perror("execve");
		if (access(ptr, X_OK) == -1)
			exit(126);
	}
	else
	{
		if (wait(&status) == -1)
			perror("wait");
	}
}

// void  execution_cmd(t_command 	*list ,char **new, char **env)
// {
// 	(void)new;

// 		char *ptr ;
// 		int pid = fork();
// 		if(pid < 0)
// 			perror("fork");

// 		else if(pid == 0)
// 		{
// 			if(herdoc_exist(list) == 1)
// 			{
// 				handle_here_doc(list,env);
// 			}
// 		printf("-------------------------------------------------------------------------------------------\n\n");
// 			if (list->arg[0][0] == '/')
// 				ptr = list->arg[0];
// 			else
// 				ptr = path_command(list->arg[0]);
// 			if (!ptr)
// 			{
// 				hundle_redirections(list);
// 				exit(127);
// 			}
// 			hundle_redirections(list);
// 			if(execve(ptr, list->arg , env) == -1)
// 				perror("execve");
// 			if (access(ptr, X_OK) == -1)
// 				exit(126);
// 		}
// 		else
// 		{
// 			int status;
// 			if(wait(&status) == -1)
// 				perror("wait");
// 		}
// }

int	hundle_redirections(t_command *list)
{
	t_redirect	*tmp;
	int			redir;

	redir = 0;
	tmp = list->doc;
	while (tmp != NULL)
	{
		if (tmp->type == REDIR_OUT)
		{
			hundle_redir_out(tmp->store);
			redir = 1;
		}
		else if (tmp->type == REDIR_IN)
		{
			hundle_redir_in(tmp->store);
			redir = 1;
		}
		else if (tmp->type == DREDIR_OUT)
		{
			hundle_dredir_out(tmp->store);
			redir = 1;
		}
		tmp = tmp->next;
	}
	list = list->next;
	return (redir);
}

int	built_in(t_envarment *var, t_command *list, char **env)
{
	if (list == NULL)
		return (0);
	if (ft_strcmp(list->content, "exit") == 0)
		return (ft_exit(var, list));
	if (ft_strcmp(list->content, "cd") == 0)
		return (ft_cd(list));
	if (ft_strcmp(list->content, "pwd") == 0)
		return (ft_pwd(list));
	if (ft_strcmp(list->content, "export") == 0)
		return (ft_export(var, list));
	if (ft_strcmp(list->content, "unset") == 0)
		return (ft_unset(var, list));
	if (ft_strcmp(list->content, "env") == 0)
		return (ft_env(var));
	if (ft_strcmp(list->content, "echo") == 0)
		return (ft_echo(list, env));
	return (0);
}
void	ft_exute(t_envarment *var, t_command *list, char **env)
{
	char	**new;
	char	**new;

	printf("***************************************************************\n");
	printf("**************    \033[0;31m   Result of the Command   \033[0m******************\n");
	printf("***************************************************************\n\n");
	if (list == NULL)
		return ;
	// if(herdoc_exist(list) == 1)
	// {
	// 	built_in( var ,list  ,env);
	// 	handle_here_doc(list,env);
	// }
	// if( pipe_exist(list) == 1)
	// {
	// 	built_in( var ,list  ,env);
	// 	handle_pipe(list, env);
	// }
	// else
	// {
	// 	// char **new = ft_new_args(list->arg, list->doc);
	// 	// (void)new;
	// 	// built_in( var ,list  ,env);
	// 	if(built_in( var ,list  ,env) == 0)
	// 		execution_cmd(list, list->arg ,env);
	// }
	// if (herdoc_exist(list))
	// {
	// 	handle_here_doc(list, env);
	// }
	if (built_in(var, list, env))
	{
		return ;
	}
	if (pipe_exist(list))
	{
		if (test_redir_here_doc(list) == 1)
		{
			printf("..................................................\n");
			new = ft_new_args(list->arg, list->doc);
			execution_cmd(list, new, env);
		}
		handle_pipe(list, env);
	}
	// if(hundle_redirections(list) == 1)
	// {
	// 	printf("..................................................\n");
	// 	char **new = ft_new_args(list->arg, list->doc);
	// 	execution_cmd(list, new,env);
	// }
	else
	{
		if (test_redir_here_doc(list) == 1)
		{
			printf("..................................................\n");
			new = ft_new_args(list->arg, list->doc);
			execution_cmd(list, new, env);
		}
		else
			execution_cmd(list, list->arg, env);
	}
}

#include "../minishell.h"

int	ft_cd(t_command *list)
{
	char	*path;

	if (list->arg[1] == NULL)
	{
		path = getenv("HOME");
		if (chdir(path) == -1)
			perror("No such file or directory");
	}
	else
	{
		path = list->arg[1];
		if (chdir(path) == -1)
			perror("No such file or directory");
	}
	return (1);
}

#include "../minishell.h"

int	ft_echo(t_command *list, char **env)
{
	int		j;
	bool	flag;
	int		i;
	char	**new;
	char	**new;

	j = 0;
	flag = true;
	i = 0;
	if (list->arg[1] != NULL)
	{
		while (list->arg[1][i] && list->arg[1][i] != '\0')
		{
			if (list->arg[1][0] == '-' && list->arg[1][++i] == 'n')
				flag = true;
			else
			{
				flag = false;
				break ;
			}
			i++;
		}
	}
	else
	{
		write(1, "\n", 1);
		return (0);
	}
	if (flag == true)
	{
		ft_echo_flag(list);
		if (test_redir_here_doc(list) == 1)
		{
			new = ft_new_args(list->arg, list->doc);
			execution_cmd(list, new, env);
		}
		return (0);
	}
	i = 1;
	while (list->arg[i])
	{
		j = 0;
		while (list->arg[i][j])
		{
			write(1, &list->arg[i][j], 1);
			j++;
		}
		write(1, " ", 2);
		i++;
	}
	write(1, "\n", 1);
	if (test_redir_here_doc(list) == 1)
	{
		new = ft_new_args(list->arg, list->doc);
		execution_cmd(list, new, env);
	}
	return (1);
}

void	ft_echo_flag(t_command *list)
{
	int	i;
	int	j;

	i = 2;
	while (list->arg[i + 1] && list->arg != NULL)
	{
		j = 0;
		while (list->arg[i][j])
		{
			write(1, &list->arg[i][j], 1);
			j++;
		}
		write(1, " ", 1);
		i++;
	}
	j = 0;
	while (list->arg[i][j] && list->arg != NULL)
	{
		write(1, &list->arg[i][j], 1);
		j++;
	}
}


#include "../minishell.h"

int	ft_env(t_envarment *var)
{
	t_envarment	*ptr;

	ptr = var;
	while (ptr)
	{
		printf("%s   {***}    %s \n", ptr->var, ptr->data);
		ptr = ptr->next;
	}
	return (1);
}
#include "../minishell.h"

int	ft_len_arg(char **arg)
{
	int	i;

	i = 0;
	while (arg[i] != NULL)
		i++;
	return (i);
}

int	is_number(char *arg)
{
	int	i;

	i = 0;
	while (arg[i])
	{
		if (!ft_isdigit(arg[i]))
			return (0);
		i++;
	}
	return (1);
}

void	ft_free_when_exit(t_envarment *var, char *str, int fd, t_command *cmd)
{
	ft_putstr_fd(str, fd);
	ft_free_command(cmd);
	ft_free_env(&var);
}
int	ft_exit(t_envarment *var, t_command *cmd)
{
	int	len;

	len = ft_len_arg(cmd->arg);
	if (len == 1)
	{
		ft_free_when_exit(var, "exit\n", 1, cmd);
		exit(0);
	}
	else if (len == 2 && is_number(cmd->arg[1]))
	{
		ft_free_when_exit(var, "exit\n", 1, cmd);
		exit(ft_atoi(cmd->arg[1]));
	}
	else if (len > 2 && is_number(cmd->arg[1]))
		ft_putstr_fd(" exit: too many arguments\n", 2);
	else
	{
		ft_free_when_exit(var, "exit: numeric argument required\n", 2, cmd);
		exit(2);
	}
	return (1);
}

#include "../minishell.h"

// t_envarment 		*ft_stock_envarment(char **env)
// {
// 	t_envarment *var=NULL;
// 	char **list;
// 	int i =0;
// 	while (env[i])
// 	{
// 		list = ft_split(env[i], '=');
// 		t_envarment *elem = new_node(list[0],list[1]);
// 		add_back_node(&var , elem);
// 		free(list);
// 		i++;
// 	}
// 	return (var);
// }

int	test_exist(t_envarment *var, char **list)
{
	t_envarment	*ptr;

	ptr = var;
	while (ptr)
	{
		if (ft_strcmp(ptr->var, list[0]) == 0 && ft_strcmp(ptr->data,
				list[1]) == 0)
			return (0);
		else if (ft_strcmp(ptr->var, list[0]) == 0 && ft_strcmp(ptr->data,
				list[1]) != 0)
		{
			ptr->data = list[1];
			return (0);
		}
		ptr = ptr->next;
	}
	return (1);
}
void	free_args(char **args)
{
	if (args)
	{
		free(args[0]);
		free(args[1]);
		free(args);
	}
}
char	**split_line(char *ptr)
{
	int		i;
	int		count;
	char	**arg;

	count = 0;
	;
	arg = (char **)malloc(sizeof(char *) * 2);
	if (arg == NULL)
		return (NULL);
	i = 0;
	while (ptr[i])
	{
		if (ptr[i] == '=')
			count++;
		i++;
	}
	if (count == 0)
	{
		arg[0] = ft_strdup(ptr);
		arg[1] = ft_strdup("");
	}
	else
	{
		arg[0] = ft_substr(ptr, 0, ft_strchr(ptr, '=') - ptr);
		arg[1] = ft_strdup(ft_strchr(ptr, '=') + 1);
		if (arg[1][0] == '\0')
			arg[1] = ft_strdup("\"\"");
	}
	if (arg[0] == NULL || arg[1] == NULL)
		return (free_args(arg), NULL);
	return (arg);
}
void	print_export(t_envarment *var, t_command *str)
{
	if (str->arg[1] == NULL)
	{
		while (var)
		{
			printf("declare -x %s=\"%s\"\n", (char *)var->var,
				(char *)var->data);
			var = var->next;
		}
	}
}

int	ft_export(t_envarment *var, t_command *str)
{
	char		**list;
	int			i;
	t_envarment	*elem;

	i = 1;
	while (str->arg[i] != NULL)
	{
		list = split_line(str->arg[i]);
		if (test_exist(var, list) == 0)
		{
			i++;
			break ;
		}
		else
		{
			elem = new_node(list[0], list[1]);
			add_back_node(&var, elem);
		}
		free(list);
		i++;
	}
	print_export(var, str);
	return (1);
}



#include "../minishell.h"

int	herdoc_exist(t_command *list)
{
	t_command	*tmp;

	tmp = list;
	while (tmp)
	{
		if (tmp->store_her && tmp->store_her[0] != NULL)
			return (1);
		tmp = tmp->next;
	}
	return (0);
}
t_here_doc	*return_herdoc(t_command *list)
{
	t_here_doc	*her;
	int			idx;
	int			i;

	her = NULL;
	idx = 0;
	while (list)
	{
		i = 0;
		while (list->store_her != NULL && list->store_her[i])
		{
			add_back_node_her(&her, new_node_her(idx, i, list->store_her[i], -1,
					false));
			i++;
		}
		idx++;
		list = list->next;
	}
	return (her);
}

void	redirect_heredoc_input(char *file, int fd)
{
	fd = open(file, O_CREAT | O_WRONLY | O_APPEND, 0600);
	if (fd < 0)
	{
		perror("open");
		return ;
	}
	close(fd);
}
void	hundle_output_herdoc(t_here_doc *her)
{
	char	*tmp_line;
	char	*path_file;

	tmp_line = ft_strjoin(her->store, ft_itoa(her->indx));
	path_file = ft_strjoin("/tmp/herdoc", tmp_line);
	free(tmp_line);
	her->fd = open(path_file, O_RDONLY, 0600);
	if (her->fd < 0)
	{
		perror("open");
		free(path_file);
		return ;
	}
	if (dup2(her->fd, STDIN_FILENO) < 0)
	{
		perror("dup2");
		close(her->fd);
		free(path_file);
		return ;
	}
	close(her->fd);
	free(path_file);
}

void	delet_file_her(t_here_doc *delet_her)
{
	char	*path_file;
	char	*tmp_line;

	while (delet_her)
	{
		tmp_line = ft_strjoin(delet_her->store, ft_itoa(delet_her->indx));
		path_file = ft_strjoin("/tmp/herdoc", tmp_line);
		if (unlink(path_file) == -1)
		{
			perror("unlink");
		}
		free(tmp_line);
		free(path_file);
		delet_her = delet_her->next;
	}
}
void	create_files(t_here_doc *her)
{
	t_here_doc	*tmp;
	char		*path_file;
	char		*tmp_line;

	tmp = her;
	while (tmp)
	{
		tmp_line = ft_strjoin(tmp->store, ft_itoa(tmp->indx));
		path_file = ft_strjoin("/tmp/herdoc", tmp_line);
		free(tmp_line);
		redirect_heredoc_input(path_file, tmp->fd);
		free(path_file);
		tmp = tmp->next;
	}
}

void	write_in_file(t_here_doc *tmp, char *line)
{
	char	*tmp_line;
	char	*path_file;

	tmp_line = ft_strjoin(tmp->store, ft_itoa(tmp->indx));
	path_file = ft_strjoin("/tmp/herdoc", tmp_line);
	free(tmp_line);
	tmp->fd = open(path_file, O_CREAT | O_WRONLY | O_APPEND, 0600);
	if (tmp->fd < 0)
	{
		perror("open");
		return ;
	}
	ft_putstr_fd(line, tmp->fd);
	write(tmp->fd, "\n", 1);
	close(tmp->fd);
	tmp = tmp->next;
}

void	handle_here_doc(t_command *tmp, char **env)
{
	int			i;
	int			count;
	t_here_doc	*her;
	t_here_doc	*tmp_her;
	char		*line;
	t_here_doc	*delet_her;

	(void)env;
	i = 0;
	count = tmp->len;
	her = return_herdoc(tmp);
	printf("*/++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	tmp_her = her;
	while (tmp_her != NULL)
	{
		printf("her->file = %s et indx = %d et i = %d   et fd = %d \n",
			tmp_her->store, tmp_her->indx, tmp_her->indx, tmp_her->fd);
		tmp_her = tmp_her->next;
	}
	printf("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
	create_files(her);
	while (1)
	{
		line = readline("> ");
		if (!line)
			break ;
		if (ft_strcmp(line, her->store) == 0)
		{
			i++;
			if (i == count || her->next == NULL)
			{
				free(line);
				break ;
			}
			her = her->next;
		}
		else
		{
			write_in_file(her, line);
		}
		free(line);
	}
	hundle_output_herdoc(her);
	delet_her = return_herdoc(tmp);
	delet_file_her(delet_her);
}




#include "../minishell.h"

int 	 ft_pwd(t_command *list)
{
	(void)list;
	char *path ;
			path = getcwd(NULL, 0);
			if(path == NULL)
				return 0;
			printf("%s\n", path);	

	return (1);
}


#include "../minishell.h"

int	ft_unset(t_envarment *var, t_command *list)
{
	t_envarment *env, *env_1;
	env = var;
	env_1 = var;
	int i = 1;

	while (list->arg[i])
	{
		while (env_1)
		{
			if (ft_strcmp(env_1->var, list->arg[i]) == 0)
			{
				env->next = env_1->next;
				free(env_1);
			}
			env = env_1;
			env_1 = env_1->next;
		}
		env = var;
		env_1 = var;
		i++;
	}
	return (1);
}



#include "../minishell.h"

char	*git_type_redir(t_redirect *redir)
{
	if (redir == NULL)
		return (NULL);
	else
	{	
		if (redir->type == REDIR_OUT)
			return (">");
		else if (redir->type == REDIR_IN)
			return ("<");
		else if (redir->type == DREDIR_OUT)
			return (">>");
		else if (redir->type == HERE_DOC)
			return ("<<");
		return (NULL);
	}
}
char 	**get_len(char **args , t_redirect *redir)
{
	int i;
	int count=0;
	char **new;

	i = 0;
	if(redir == NULL)
		count= 1;
	while(args[i] )
	{
		if(ft_strcmp(args[i], git_type_redir(redir)) == 0 )
		{
			i++;
			redir = redir->next;
		}
		else
			count++;
		i++;
	}
	new = (char **)malloc(sizeof(char *) * (count + 1));
	if (!new)
		return (NULL);
	return (new);
}


char	**ft_new_args(char **args , t_redirect *redir)
{
	char **new;
	int i=0;
	int j=0;

	new = get_len(args , redir );
	while(args[i])
	{
		if(ft_strcmp(args[i], git_type_redir(redir) ) == 0)
		{
			i++;
			redir = redir->next;
		}
		else
		{
			new[j] = ft_strdup(args[i]);
			j++;
		}
		i++;
	}
	new[j] = NULL;
	return (new);	
}
int 	test_redir_here_doc(t_command *list)
{
	if (list == NULL)
		return (0);
	t_redirect *tmp;
	tmp = list->doc;
	while (tmp != NULL)
	{
		if (tmp->type == HERE_DOC || tmp->type == DREDIR_OUT || tmp->type == REDIR_OUT || tmp->type == REDIR_IN)
			return (1);
		tmp = tmp->next;
	}
	return (0);
}





#include "../minishell.h"


int ft_strcmp(char *s1, char *s2)
{
	if(!s1 || !s2)
		return -1;
	int i =0;
	while((s1[i] == s2[i]) && s1[i] && s2[i])
	{
		i++;
	}
	return (s1[i] - s2[i]);

}
char **create_argv(t_splitor *elem) 
{
	int count = 0;
	char **argv;
	t_splitor *tmp ;

	tmp = elem;
	while (tmp)
	{
		count++;
		tmp = tmp->next;
	}
	argv = (char **)malloc(sizeof(char *) * (count + 1));
	if (!argv)
		return (NULL);
	tmp = elem;
	int i = 0;
	while (tmp)
	{
		argv[i] = ft_strdup(tmp->in);
		if(!argv[i])
		{
			int j = 0;
			while (j < i)
			{
				free(argv[j]);
				j++;
			}
		}
		i++;
		tmp = tmp->next;
	}
	argv[count] = NULL;
	return argv;
}


char 	*path_command(char *ptr)
{
	char *path;
	char **list;
	int i=0;
	int a;
	char *tmp ;
	char *tmp2;

	path  = getenv("PATH");
	if(!path)
		perror("Error: PATH not found\n");
	
	list = ft_split(path, ':');
	while (list[i])
	{
		if(ptr[0] == '/')
			tmp2 = ptr;
		else
		{
			tmp = ft_strjoin(list[i], "/");
			tmp2 = ft_strjoin(tmp, ptr);
		}
		a = access(tmp2, F_OK) ;
		if (a == 0)
		{
			// free(ptr);
			return tmp2;
		}
		i++;
	}
	// free(ptr);
	ptr =NULL;
return ptr;
}


#include "../minishell.h"

void	hundle_redir_out(char *file)
{
	int	fd;

	fd = open(file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd < 0)
	{
		perror("open");
		exit(EXIT_FAILURE);
	}
	if (dup2(fd, STDOUT_FILENO) < 0)
	{
		perror("dup2");
		exit(EXIT_FAILURE);
	}
	close(fd);
}

void	hundle_redir_in(char *file)
{
	int	fd;

	fd = open(file, O_RDONLY);
	if (fd < 0)
	{
		perror("open");
		exit(EXIT_FAILURE);
	}
	if (dup2(fd, STDIN_FILENO) < 0)
	{
		perror("dup2");
		exit(EXIT_FAILURE);
	}
	close(fd);
}

void	hundle_dredir_out(char *file)
{
	int	fd;

	fd = open(file, O_WRONLY | O_CREAT | O_APPEND, 0644);
	if (fd < 0)
	{
		perror("open");
		exit(EXIT_FAILURE);
	}
	if (dup2(fd, STDOUT_FILENO) < 0)
	{
		perror("dup2");
		exit(EXIT_FAILURE);
	}
	close(fd);
}



#include "../minishell.h"

t_here_doc	*new_node_her(int idx, int i, char *file, int fd, bool expand)
{
	t_here_doc	*elem;

	elem = (t_here_doc *)malloc(sizeof(t_here_doc));
	if (!elem)
		return (NULL);
	elem->indx_cmd = idx;
	elem->indx = i, elem->store = file;
	elem->fd = fd;
	elem->is_expanded = expand;
	elem->next = NULL;
	return (elem);
}

void	add_back_node_her(t_here_doc **her, t_here_doc *new_her)
{
	t_here_doc	*p;

	p = *her;
	if (!her || !new_her)
		return ;
	if (!(*her))
	{
		*her = new_her;
		return ;
	}
	while (p->next)
	{
		p = p->next;
	}
	p->next = new_her;
}
